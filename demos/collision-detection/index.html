<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapLibre GL JS - è¤‡é›‘ãªå½¢çŠ¶ã§ã®é«˜ç²¾åº¦è¡çªåˆ¤å®š</title>
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <style>
        body { margin: 0; padding: 0; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1;
            max-width: 380px;
        }
        
        .info-panel h3 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .control-section {
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        
        .control-label {
            font-weight: bold;
            margin-bottom: 8px;
            color: #555;
            font-size: 14px;
        }
        
        .size-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
        }
        
        .size-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }
        
        .size-slider:hover {
            background: #ccc;
        }
        
        .size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4444ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        
        .size-slider::-webkit-slider-thumb:hover {
            background: #6666ff;
            transform: scale(1.1);
        }
        
        .size-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4444ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            border: none;
            transition: all 0.2s;
        }
        
        .size-slider::-moz-range-thumb:hover {
            background: #6666ff;
            transform: scale(1.1);
        }
        
        .size-value {
            min-width: 45px;
            text-align: center;
            font-weight: bold;
            color: #4444ff;
            font-size: 16px;
        }
        
        .size-presets {
            display: flex;
            gap: 5px;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        
        .preset-btn {
            padding: 3px 8px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .preset-btn:hover {
            background: #f0f0f0;
            border-color: #4444ff;
        }
        
        .status {
            padding: 8px 12px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .status.safe {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.collision {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            animation: pulse 0.5s;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .coordinates {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }
        
        .collision-list {
            margin-top: 10px;
            font-size: 14px;
        }
        
        .collision-item {
            background: #fff3cd;
            padding: 5px 8px;
            margin: 5px 0;
            border-radius: 3px;
            border-left: 3px solid #ffc107;
        }
        
        .shape-selector {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-top: 8px;
        }
        
        .shape-btn {
            padding: 5px 10px;
            border: 2px solid #4444ff;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        .shape-btn.active {
            background: #4444ff;
            color: white;
        }
        
        .shape-btn:hover {
            background: #6666ff;
            color: white;
        }
        
        .debug-info {
            font-size: 11px;
            color: #999;
            margin-top: 5px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .stat-item {
            padding: 5px;
            background: #f0f0f0;
            border-radius: 3px;
        }
        
        .stat-label {
            color: #666;
            font-size: 10px;
        }
        
        .stat-value {
            font-weight: bold;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="info-panel">
        <h3>ğŸ¯ é«˜ç²¾åº¦è¡çªåˆ¤å®šãƒ‡ãƒ¢</h3>
        
        <div class="control-section">
            <div class="control-label">ğŸ“ å½¢çŠ¶ã‚’é¸æŠ</div>
            <div class="shape-selector">
                <button class="shape-btn active" data-shape="star">â­ æ˜Ÿå½¢</button>
                <button class="shape-btn" data-shape="hexagon">â¬¡ å…­è§’å½¢</button>
                <button class="shape-btn" data-shape="triangle">â–² ä¸‰è§’å½¢</button>
                <button class="shape-btn" data-shape="cross">âœš åå­—</button>
                <button class="shape-btn" data-shape="circle">â— å††å½¢</button>
            </div>
        </div>
        
        <div class="control-section">
            <div class="control-label">ğŸ“ ã‚µã‚¤ã‚ºèª¿æ•´</div>
            <div class="size-control">
                <span style="font-size: 12px;">10m</span>
                <input type="range" class="size-slider" id="sizeSlider" 
                       min="10" max="60" value="25" step="1">
                <span style="font-size: 12px;">60m</span>
                <div class="size-value" id="sizeValue">25m</div>
            </div>
            <div class="size-presets">
                <button class="preset-btn" data-size="10">æ¥µå°</button>
                <button class="preset-btn" data-size="15">å°</button>
                <button class="preset-btn" data-size="25">æ¨™æº–</button>
                <button class="preset-btn" data-size="35">å¤§</button>
                <button class="preset-btn" data-size="50">ç‰¹å¤§</button>
                <button class="preset-btn" data-size="60">æœ€å¤§</button>
            </div>
        </div>
        
        <div id="status" class="status safe">è¡çªãªã—</div>
        <div id="collisions" class="collision-list"></div>
        
        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-label">ç¾åœ¨ã®å½¢çŠ¶</div>
                <div class="stat-value" id="currentShapeDisplay">æ˜Ÿå½¢</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">ç¾åœ¨ã®ã‚µã‚¤ã‚º</div>
                <div class="stat-value" id="currentSizeDisplay">25m</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">é¢ç©ï¼ˆæ¦‚ç®—ï¼‰</div>
                <div class="stat-value" id="areaDisplay">-</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">é ‚ç‚¹æ•°</div>
                <div class="stat-value" id="verticesDisplay">-</div>
            </div>
        </div>
        
        <div id="coordinates" class="coordinates"></div>
        <div id="debug" class="debug-info"></div>
    </div>

    <script>
        // ãƒãƒƒãƒ—ã®åˆæœŸåŒ–
        const map = new maplibregl.Map({
            container: 'map',
            style: {
                version: 8,
                sources: {
                    'osm': {
                        type: 'raster',
                        tiles: [
                            'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
                            'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
                            'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
                        ],
                        tileSize: 256,
                        attribution: 'Â© OpenStreetMap contributors'
                    }
                },
                layers: [{
                    id: 'osm',
                    type: 'raster',
                    source: 'osm'
                }]
            },
            center: [139.7670, 35.6814],
            zoom: 16
        });

        // ç¾åœ¨ã®è¨­å®š
        let currentShape = 'star';
        let currentSize = 25; // ãƒ¡ãƒ¼ãƒˆãƒ«å˜ä½
        
        // å½¢çŠ¶åã®ãƒãƒƒãƒ”ãƒ³ã‚°
        const shapeNames = {
            'star': 'æ˜Ÿå½¢',
            'hexagon': 'å…­è§’å½¢',
            'triangle': 'ä¸‰è§’å½¢',
            'cross': 'åå­—å½¢',
            'circle': 'å††å½¢'
        };
        
        // å½¢çŠ¶ç”Ÿæˆé–¢æ•°ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«å˜ä½ã§åº§æ¨™ã‚’ç”Ÿæˆï¼‰
        function createShape(type, center, sizeInMeters) {
            const [lng, lat] = center;
            const earthRadius = 6371000; // åœ°çƒã®åŠå¾„ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
            
            // ãƒ¡ãƒ¼ãƒˆãƒ«ã‚’ç·¯åº¦ãƒ»çµŒåº¦ã«å¤‰æ›
            const latOffset = (sizeInMeters / earthRadius) * (180 / Math.PI);
            const lngOffset = (sizeInMeters / earthRadius) * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
            
            let points = [];
            
            switch(type) {
                case 'star':
                    // 5èŠ’æ˜Ÿã‚’ç”Ÿæˆ
                    for (let i = 0; i < 10; i++) {
                        const angle = (Math.PI * 2 * i) / 10 - Math.PI / 2;
                        const radius = i % 2 === 0 ? 1 : 0.4; // å¤–å´ã¨å†…å´ã®é ‚ç‚¹
                        points.push([
                            lng + lngOffset * radius * Math.cos(angle),
                            lat + latOffset * radius * Math.sin(angle)
                        ]);
                    }
                    break;
                    
                case 'hexagon':
                    // å…­è§’å½¢ã‚’ç”Ÿæˆ
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 * i) / 6;
                        points.push([
                            lng + lngOffset * Math.cos(angle),
                            lat + latOffset * Math.sin(angle)
                        ]);
                    }
                    break;
                    
                case 'triangle':
                    // æ­£ä¸‰è§’å½¢ã‚’ç”Ÿæˆ
                    for (let i = 0; i < 3; i++) {
                        const angle = (Math.PI * 2 * i) / 3 - Math.PI / 2;
                        points.push([
                            lng + lngOffset * Math.cos(angle),
                            lat + latOffset * Math.sin(angle)
                        ]);
                    }
                    break;
                    
                case 'cross':
                    // åå­—å½¢ã‚’ç”Ÿæˆ
                    const w = 0.3; // å¹…ã®ä¿‚æ•°
                    points = [
                        [lng - lngOffset * w, lat + latOffset],
                        [lng + lngOffset * w, lat + latOffset],
                        [lng + lngOffset * w, lat + latOffset * w],
                        [lng + lngOffset, lat + latOffset * w],
                        [lng + lngOffset, lat - latOffset * w],
                        [lng + lngOffset * w, lat - latOffset * w],
                        [lng + lngOffset * w, lat - latOffset],
                        [lng - lngOffset * w, lat - latOffset],
                        [lng - lngOffset * w, lat - latOffset * w],
                        [lng - lngOffset, lat - latOffset * w],
                        [lng - lngOffset, lat + latOffset * w],
                        [lng - lngOffset * w, lat + latOffset * w]
                    ];
                    break;
                    
                case 'circle':
                    // å††å½¢ï¼ˆ32è§’å½¢ã§è¿‘ä¼¼ï¼‰
                    for (let i = 0; i < 32; i++) {
                        const angle = (Math.PI * 2 * i) / 32;
                        points.push([
                            lng + lngOffset * Math.cos(angle),
                            lat + latOffset * Math.sin(angle)
                        ]);
                    }
                    break;
            }
            
            // ãƒãƒªã‚´ãƒ³ã‚’é–‰ã˜ã‚‹
            points.push(points[0]);
            return points;
        }

        // ãƒãƒªã‚´ãƒ³ã®é¢ç©ã‚’è¨ˆç®—ï¼ˆShoelace formulaï¼‰
        function calculatePolygonArea(polygon) {
            let area = 0;
            const n = polygon.length - 1; // æœ€å¾Œã®ç‚¹ã¯æœ€åˆã¨åŒã˜
            
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                // ç·¯åº¦çµŒåº¦ã‚’ãƒ¡ãƒ¼ãƒˆãƒ«ã«å¤‰æ›ã—ã¦è¨ˆç®—
                const earthRadius = 6371000;
                const lat = polygon[i][1];
                const x1 = polygon[i][0] * Math.PI / 180 * earthRadius * Math.cos(lat * Math.PI / 180);
                const y1 = polygon[i][1] * Math.PI / 180 * earthRadius;
                const x2 = polygon[j][0] * Math.PI / 180 * earthRadius * Math.cos(lat * Math.PI / 180);
                const y2 = polygon[j][1] * Math.PI / 180 * earthRadius;
                
                area += (x1 * y2 - x2 * y1);
            }
            
            return Math.abs(area) / 2;
        }

        // ãƒãƒªã‚´ãƒ³è¡çªåˆ¤å®šï¼ˆSAT: Separating Axis Theoremï¼‰
        function polygonsIntersect(poly1, poly2) {
            // ç‚¹ãŒãƒãƒªã‚´ãƒ³å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆRay Casting Algorithmï¼‰
            function pointInPolygon(point, polygon) {
                let inside = false;
                const x = point[0], y = point[1];
                
                for (let i = 0, j = polygon.length - 2; i < polygon.length - 1; j = i++) {
                    const xi = polygon[i][0], yi = polygon[i][1];
                    const xj = polygon[j][0], yj = polygon[j][1];
                    
                    const intersect = ((yi > y) !== (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                
                return inside;
            }
            
            // ç·šåˆ†ã®äº¤å·®åˆ¤å®š
            function lineSegmentsIntersect(p1, p2, p3, p4) {
                const ccw = (A, B, C) => {
                    return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0]);
                };
                return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
            }
            
            // ã„ãšã‚Œã‹ã®é ‚ç‚¹ãŒç›¸æ‰‹ã®ãƒãƒªã‚´ãƒ³å†…ã«ã‚ã‚‹å ´åˆ
            for (let i = 0; i < poly1.length - 1; i++) {
                if (pointInPolygon(poly1[i], poly2)) return true;
            }
            for (let i = 0; i < poly2.length - 1; i++) {
                if (pointInPolygon(poly2[i], poly1)) return true;
            }
            
            // ã‚¨ãƒƒã‚¸åŒå£«ã®äº¤å·®ã‚’ãƒã‚§ãƒƒã‚¯
            for (let i = 0; i < poly1.length - 1; i++) {
                for (let j = 0; j < poly2.length - 1; j++) {
                    if (lineSegmentsIntersect(
                        poly1[i], poly1[i + 1],
                        poly2[j], poly2[j + 1]
                    )) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // ãƒãƒªã‚´ãƒ³ã®ä¸­å¿ƒç‚¹ã‚’è¨ˆç®—
        function getPolygonCenter(polygon) {
            let sumLng = 0, sumLat = 0;
            const count = polygon.length - 1; // æœ€å¾Œã®ç‚¹ã¯æœ€åˆã®ç‚¹ã¨åŒã˜
            for (let i = 0; i < count; i++) {
                sumLng += polygon[i][0];
                sumLat += polygon[i][1];
            }
            return [sumLng / count, sumLat / count];
        }

        // è·é›¢è¨ˆç®—
        function calculateDistance(coord1, coord2) {
            const R = 6371000;
            const rad = Math.PI / 180;
            const lat1 = coord1[1] * rad;
            const lat2 = coord2[1] * rad;
            const deltaLat = (coord2[1] - coord1[1]) * rad;
            const deltaLng = (coord2[0] - coord1[0]) * rad;

            const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                     Math.cos(lat1) * Math.cos(lat2) *
                     Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            
            return R * c;
        }

        // POIãƒ‡ãƒ¼ã‚¿
        const poiData = {
            type: 'FeatureCollection',
            features: [
                {
                    type: 'Feature',
                    properties: { 
                        name: 'æ±äº¬é§…',
                        shapeType: 'hexagon',
                        size: 30
                    },
                    geometry: {
                        type: 'Polygon',
                        coordinates: [createShape('hexagon', [139.7671, 35.6812], 30)]
                    }
                },
                {
                    type: 'Feature',
                    properties: { 
                        name: 'çš‡å±…',
                        shapeType: 'star',
                        size: 40
                    },
                    geometry: {
                        type: 'Polygon',
                        coordinates: [createShape('star', [139.7536, 35.6852], 40)]
                    }
                },
                {
                    type: 'Feature',
                    properties: { 
                        name: 'æ—¥æ¯”è°·å…¬åœ’',
                        shapeType: 'triangle',
                        size: 35
                    },
                    geometry: {
                        type: 'Polygon',
                        coordinates: [createShape('triangle', [139.7563, 35.6742], 35)]
                    }
                },
                {
                    type: 'Feature',
                    properties: { 
                        name: 'éŠ€åº§',
                        shapeType: 'cross',
                        size: 30
                    },
                    geometry: {
                        type: 'Polygon',
                        coordinates: [createShape('cross', [139.7638, 35.6719], 30)]
                    }
                },
                {
                    type: 'Feature',
                    properties: { 
                        name: 'æœ‰æ¥½ç”ºé§…',
                        shapeType: 'circle',
                        size: 25
                    },
                    geometry: {
                        type: 'Polygon',
                        coordinates: [createShape('circle', [139.7638, 35.6751], 25)]
                    }
                }
            ]
        };

        // ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ãƒãƒ¼ã‚«ãƒ¼ã®åˆæœŸãƒ‡ãƒ¼ã‚¿
        let draggableCenter = [139.7600, 35.6780];
        const draggableMarker = {
            type: 'FeatureCollection',
            features: [{
                type: 'Feature',
                properties: { 
                    name: 'ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½å›³å½¢',
                    shapeType: currentShape,
                    size: currentSize
                },
                geometry: {
                    type: 'Polygon',
                    coordinates: [createShape(currentShape, draggableCenter, currentSize)]
                }
            }]
        };

        // è¡çªåˆ¤å®š
        function checkCollisions() {
            const collisions = [];
            const draggablePolygon = draggableMarker.features[0].geometry.coordinates[0];
            
            poiData.features.forEach(poi => {
                const poiPolygon = poi.geometry.coordinates[0];
                
                if (polygonsIntersect(draggablePolygon, poiPolygon)) {
                    const poiCenter = getPolygonCenter(poiPolygon);
                    const distance = calculateDistance(draggableCenter, poiCenter);
                    
                    collisions.push({
                        name: poi.properties.name,
                        shapeType: poi.properties.shapeType,
                        size: poi.properties.size,
                        distance: Math.round(distance),
                        intersecting: true
                    });
                }
            });
            
            return collisions;
        }

        // çµ±è¨ˆæƒ…å ±ã®æ›´æ–°
        function updateStats() {
            const polygon = draggableMarker.features[0].geometry.coordinates[0];
            const area = calculatePolygonArea(polygon);
            const vertices = polygon.length - 1; // æœ€å¾Œã®ç‚¹ã‚’é™¤ã
            
            document.getElementById('currentShapeDisplay').textContent = shapeNames[currentShape];
            document.getElementById('currentSizeDisplay').textContent = `${currentSize}m`;
            document.getElementById('areaDisplay').textContent = `${Math.round(area)}mÂ²`;
            document.getElementById('verticesDisplay').textContent = vertices;
        }

        // UIæ›´æ–°
        function updateUI() {
            const collisions = checkCollisions();
            const statusEl = document.getElementById('status');
            const collisionsEl = document.getElementById('collisions');
            const coordsEl = document.getElementById('coordinates');
            const debugEl = document.getElementById('debug');
            
            coordsEl.innerHTML = `ä¸­å¿ƒåº§æ¨™: [${draggableCenter[0].toFixed(4)}, ${draggableCenter[1].toFixed(4)}]`;
            debugEl.innerHTML = `åˆ¤å®šæ–¹å¼: ãƒãƒªã‚´ãƒ³äº¤å·®åˆ¤å®š | ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«: ${map.getZoom().toFixed(1)}`;
            
            updateStats();
            
            if (collisions.length > 0) {
                statusEl.className = 'status collision';
                statusEl.textContent = `âš ï¸ ${collisions.length}ä»¶ã®è¡çªã‚’æ¤œå‡º`;
                
                collisionsEl.innerHTML = collisions.map(c => 
                    `<div class="collision-item">
                        <strong>${c.name}</strong> (${c.shapeType}, ${c.size}m)
                        <br>ä¸­å¿ƒé–“è·é›¢: ${c.distance}m
                        <br>çŠ¶æ…‹: ãƒãƒªã‚´ãƒ³ãŒäº¤å·®
                    </div>`
                ).join('');
                
                // è¡çªã—ã¦ã„ã‚‹å›³å½¢ã‚’èµ¤ãè¡¨ç¤º
                map.setPaintProperty('draggable-fill', 'fill-color', 'rgba(255, 100, 100, 0.6)');
                map.setPaintProperty('draggable-outline', 'line-color', '#ff4444');
            } else {
                statusEl.className = 'status safe';
                statusEl.textContent = 'âœ“ è¡çªãªã—';
                collisionsEl.innerHTML = '';
                
                // é€šå¸¸ã®è‰²ã«æˆ»ã™
                map.setPaintProperty('draggable-fill', 'fill-color', 'rgba(100, 100, 255, 0.4)');
                map.setPaintProperty('draggable-outline', 'line-color', '#4444ff');
            }
        }

        // å½¢çŠ¶ã¨ã‚µã‚¤ã‚ºã®æ›´æ–°
        function updateDraggableShapeAndSize() {
            draggableMarker.features[0].geometry.coordinates = [
                createShape(currentShape, draggableCenter, currentSize)
            ];
            draggableMarker.features[0].properties.shapeType = currentShape;
            draggableMarker.features[0].properties.size = currentSize;
            
            if (map.getSource('draggable')) {
                map.getSource('draggable').setData(draggableMarker);
                updateUI();
            }
        }

        // ã‚µã‚¤ã‚ºã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆ
        const sizeSlider = document.getElementById('sizeSlider');
        const sizeValue = document.getElementById('sizeValue');
        
        sizeSlider.addEventListener('input', (e) => {
            currentSize = parseInt(e.target.value);
            sizeValue.textContent = `${currentSize}m`;
            updateDraggableShapeAndSize();
        });

        // ãƒ—ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆ
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const size = parseInt(e.target.dataset.size);
                currentSize = size;
                sizeSlider.value = size;
                sizeValue.textContent = `${size}m`;
                updateDraggableShapeAndSize();
            });
        });

        // å½¢çŠ¶é¸æŠãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆ
        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                currentShape = e.target.dataset.shape;
                updateDraggableShapeAndSize();
            });
        });

        map.on('load', () => {
            // POIã®è¿½åŠ 
            map.addSource('pois', {
                type: 'geojson',
                data: poiData
            });
            
            // POIã®ãƒãƒªã‚´ãƒ³è¡¨ç¤º
            map.addLayer({
                id: 'poi-fill',
                type: 'fill',
                source: 'pois',
                paint: {
                    'fill-color': 'rgba(255, 100, 100, 0.4)',
                    'fill-outline-color': '#ff4444'
                }
            });
            
            // POIã®è¼ªéƒ­ç·š
            map.addLayer({
                id: 'poi-outline',
                type: 'line',
                source: 'pois',
                paint: {
                    'line-color': '#ff4444',
                    'line-width': 2
                }
            });
            
            // POIãƒ©ãƒ™ãƒ«
            map.addLayer({
                id: 'poi-labels',
                type: 'symbol',
                source: 'pois',
                layout: {
                    'text-field': ['concat', ['get', 'name'], '\n', ['get', 'size'], 'm'],
                    'text-size': 11,
                    'text-anchor': 'center',
                    'text-line-height': 1.2
                },
                paint: {
                    'text-color': '#333',
                    'text-halo-color': '#fff',
                    'text-halo-width': 2
                }
            });
            
            // ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ãƒãƒ¼ã‚«ãƒ¼ã®è¿½åŠ 
            map.addSource('draggable', {
                type: 'geojson',
                data: draggableMarker
            });
            
            // ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ãƒãƒ¼ã‚«ãƒ¼ã®ãƒãƒªã‚´ãƒ³è¡¨ç¤º
            map.addLayer({
                id: 'draggable-fill',
                type: 'fill',
                source: 'draggable',
                paint: {
                    'fill-color': 'rgba(100, 100, 255, 0.4)',
                    'fill-outline-color': '#4444ff'
                }
            });
            
            // ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ãƒãƒ¼ã‚«ãƒ¼ã®è¼ªéƒ­ç·š
            map.addLayer({
                id: 'draggable-outline',
                type: 'line',
                source: 'draggable',
                paint: {
                    'line-color': '#4444ff',
                    'line-width': 3
                }
            });
            
            // ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ãƒãƒ¼ã‚«ãƒ¼ã®ãƒ©ãƒ™ãƒ«
            map.addLayer({
                id: 'draggable-label',
                type: 'symbol',
                source: 'draggable',
                layout: {
                    'text-field': ['concat', 'ãƒ‰ãƒ©ãƒƒã‚°\n', ['get', 'size'], 'm'],
                    'text-size': 11,
                    'text-anchor': 'center',
                    'text-line-height': 1.2
                },
                paint: {
                    'text-color': '#fff',
                    'text-halo-color': '#4444ff',
                    'text-halo-width': 2
                }
            });
            
            // ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½
            let isDragging = false;
            
            map.on('mouseenter', 'draggable-fill', () => {
                map.getCanvas().style.cursor = 'move';
            });
            
            map.on('mouseleave', 'draggable-fill', () => {
                if (!isDragging) {
                    map.getCanvas().style.cursor = '';
                }
            });
            
            map.on('mousedown', 'draggable-fill', (e) => {
                e.preventDefault();
                isDragging = true;
                map.getCanvas().style.cursor = 'grabbing';
                map.dragPan.disable();
            });
            
            map.on('mousemove', (e) => {
                if (!isDragging) return;
                
                draggableCenter = [e.lngLat.lng, e.lngLat.lat];
                draggableMarker.features[0].geometry.coordinates = [
                    createShape(currentShape, draggableCenter, currentSize)
                ];
                map.getSource('draggable').setData(draggableMarker);
                updateUI();
            });
            
            map.on('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    map.getCanvas().style.cursor = '';
                    map.dragPan.enable();
                }
            });
            
            // ã‚¿ãƒƒãƒå¯¾å¿œ
            let touchId = null;
            
            map.on('touchstart', 'draggable-fill', (e) => {
                if (e.points.length !== 1) return;
                e.preventDefault();
                
                touchId = e.originalEvent.touches[0].identifier;
                isDragging = true;
                map.dragPan.disable();
            });
            
            map.on('touchmove', (e) => {
                if (!isDragging || touchId === null) return;
                
                const touch = e.originalEvent.touches[0];
                if (touch.identifier !== touchId) return;
                
                draggableCenter = [e.lngLat.lng, e.lngLat.lat];
                draggableMarker.features[0].geometry.coordinates = [
                    createShape(currentShape, draggableCenter, currentSize)
                ];
                map.getSource('draggable').setData(draggableMarker);
                updateUI();
            });
            
            map.on('touchend', () => {
                if (isDragging) {
                    isDragging = false;
                    touchId = null;
                    map.dragPan.enable();
                }
            });
            
            // ã‚ºãƒ¼ãƒ å¤‰æ›´æ™‚ã®æ›´æ–°
            map.on('zoom', () => {
                updateUI();
            });
            
            updateUI();
        });

        // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        map.addControl(new maplibregl.NavigationControl());
    </script>
</body>
</html>