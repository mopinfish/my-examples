<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MapLibre GL JS - PNG画像対応 高精度衝突判定</title>
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <link
      href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }
      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }

      .info-panel {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.95);
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        z-index: 1;
        max-width: 420px;
        max-height: 90vh;
        overflow-y: auto;
      }

      .info-panel h3 {
        margin: 0 0 10px 0;
        color: #333;
      }

      .control-section {
        margin: 15px 0;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 4px;
      }

      .control-label {
        font-weight: bold;
        margin-bottom: 8px;
        color: #555;
        font-size: 14px;
      }

      /* 画像アップロード部分 */
      .image-upload-section {
        border: 2px dashed #4444ff;
        border-radius: 8px;
        padding: 20px;
        text-align: center;
        background: #f0f4ff;
        margin: 15px 0;
        position: relative;
        transition: all 0.3s;
      }

      .image-upload-section.dragover {
        background: #e0e8ff;
        border-color: #2222ff;
      }

      .image-upload-section.has-image {
        background: #fff;
        border-style: solid;
      }

      .upload-input {
        display: none;
      }

      .upload-label {
        display: inline-block;
        padding: 10px 20px;
        background: #4444ff;
        color: white;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.3s;
        font-weight: bold;
      }

      .upload-label:hover {
        background: #6666ff;
      }

      .upload-hint {
        margin-top: 10px;
        font-size: 12px;
        color: #666;
      }

      .image-preview {
        display: none;
        margin-top: 15px;
      }

      .image-preview.active {
        display: block;
      }

      .preview-container {
        display: flex;
        gap: 15px;
        margin-bottom: 10px;
      }

      .preview-box {
        flex: 1;
        text-align: center;
      }

      .preview-title {
        font-size: 12px;
        color: #666;
        margin-bottom: 5px;
      }

      .preview-canvas {
        border: 1px solid #ddd;
        border-radius: 4px;
        max-width: 100%;
        background: white;
      }

      .image-info {
        font-size: 12px;
        color: #666;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 4px;
      }

      .remove-image-btn {
        margin-top: 10px;
        padding: 5px 15px;
        background: #ff4444;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      .remove-image-btn:hover {
        background: #ff6666;
      }

      /* 輪郭精度調整 */
      .contour-controls {
        margin-top: 10px;
        padding: 10px;
        background: #fff;
        border-radius: 4px;
      }

      .threshold-control {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 10px 0;
      }

      .threshold-slider {
        flex: 1;
        height: 6px;
        -webkit-appearance: none;
        appearance: none;
        background: #ddd;
        border-radius: 3px;
        outline: none;
      }

      .threshold-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        background: #4444ff;
        border-radius: 50%;
        cursor: pointer;
      }

      .threshold-value {
        min-width: 45px;
        text-align: center;
        font-weight: bold;
        color: #4444ff;
      }

      /* 既存のスタイル */
      .size-control {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 8px;
      }

      .size-slider {
        flex: 1;
        height: 6px;
        -webkit-appearance: none;
        appearance: none;
        background: #ddd;
        border-radius: 3px;
        outline: none;
      }

      .size-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: #4444ff;
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .size-value {
        min-width: 45px;
        text-align: center;
        font-weight: bold;
        color: #4444ff;
        font-size: 16px;
      }

      .shape-selector {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
        margin-top: 8px;
      }

      .shape-btn {
        padding: 5px 10px;
        border: 2px solid #4444ff;
        background: white;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 14px;
      }

      .shape-btn.active {
        background: #4444ff;
        color: white;
      }

      .shape-btn:hover {
        background: #6666ff;
        color: white;
      }

      .status {
        padding: 8px 12px;
        border-radius: 4px;
        margin: 10px 0;
        font-weight: bold;
        transition: all 0.3s ease;
      }

      .status.safe {
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }

      .status.collision {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
        animation: pulse 0.5s;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .collision-list {
        margin-top: 10px;
        font-size: 14px;
      }

      .collision-item {
        background: #fff3cd;
        padding: 5px 8px;
        margin: 5px 0;
        border-radius: 3px;
        border-left: 3px solid #ffc107;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 10px;
        font-size: 12px;
      }

      .stat-item {
        padding: 5px;
        background: #f0f0f0;
        border-radius: 3px;
      }

      .stat-label {
        color: #666;
        font-size: 10px;
      }

      .stat-value {
        font-weight: bold;
        color: #333;
      }

      .coordinates {
        font-size: 12px;
        color: #666;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <div class="info-panel">
      <h3>🎯 PNG画像対応 高精度衝突判定</h3>

      <!-- 画像アップロード -->
      <div class="image-upload-section" id="uploadSection">
        <input
          type="file"
          class="upload-input"
          id="imageUpload"
          accept="image/png"
        />
        <label for="imageUpload" class="upload-label"> 📷 PNG画像を選択 </label>
        <div class="upload-hint">
          またはドラッグ&ドロップ<br />
          透過PNG推奨（背景が透明な画像）
        </div>

        <div class="image-preview" id="imagePreview">
          <div class="preview-container">
            <div class="preview-box">
              <div class="preview-title">元画像</div>
              <canvas id="originalCanvas" class="preview-canvas"></canvas>
            </div>
            <div class="preview-box">
              <div class="preview-title">輪郭抽出</div>
              <canvas id="contourCanvas" class="preview-canvas"></canvas>
            </div>
          </div>
          <div class="image-info" id="imageInfo"></div>

          <div class="contour-controls">
            <div class="control-label">輪郭の精度調整</div>
            <div class="threshold-control">
              <span style="font-size: 12px">粗い</span>
              <input
                type="range"
                class="threshold-slider"
                id="simplifySlider"
                min="1"
                max="10"
                value="3"
                step="1"
              />
              <span style="font-size: 12px">細かい</span>
              <div class="threshold-value" id="simplifyValue">3</div>
            </div>
            <div class="threshold-control">
              <span style="font-size: 12px">透明度閾値</span>
              <input
                type="range"
                class="threshold-slider"
                id="alphaSlider"
                min="1"
                max="255"
                value="128"
                step="1"
              />
              <div class="threshold-value" id="alphaValue">128</div>
            </div>
          </div>

          <button class="remove-image-btn" onclick="removeCustomImage()">
            画像を削除
          </button>
        </div>
      </div>

      <!-- 既存の形状選択 -->
      <div class="control-section">
        <div class="control-label">📐 プリセット形状</div>
        <div class="shape-selector">
          <button class="shape-btn active" data-shape="star">⭐ 星形</button>
          <button class="shape-btn" data-shape="hexagon">⬡ 六角形</button>
          <button class="shape-btn" data-shape="triangle">▲ 三角形</button>
          <button class="shape-btn" data-shape="cross">✚ 十字</button>
          <button class="shape-btn" data-shape="circle">● 円形</button>
          <button
            class="shape-btn"
            data-shape="custom"
            id="customShapeBtn"
            style="display: none"
          >
            🖼️ カスタム
          </button>
        </div>
      </div>

      <!-- サイズ調整 -->
      <div class="control-section">
        <div class="control-label">📏 サイズ調整</div>
        <div class="size-control">
          <span style="font-size: 12px">10m</span>
          <input
            type="range"
            class="size-slider"
            id="sizeSlider"
            min="10"
            max="60"
            value="25"
            step="1"
          />
          <span style="font-size: 12px">60m</span>
          <div class="size-value" id="sizeValue">25m</div>
        </div>
      </div>

      <div id="status" class="status safe">衝突なし</div>
      <div id="collisions" class="collision-list"></div>

      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-label">現在の形状</div>
          <div class="stat-value" id="currentShapeDisplay">星形</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">頂点数</div>
          <div class="stat-value" id="verticesDisplay">-</div>
        </div>
      </div>

      <div id="coordinates" class="coordinates"></div>
    </div>

    <script>
      // グローバル変数
      let map;
      let currentShape = "star";
      let currentSize = 25;
      let customImageContour = null;
      let customImageData = null;
      let isDragging = false;
      let draggableCenter = [139.76, 35.678];

      // 形状名のマッピング
      const shapeNames = {
        star: "星形",
        hexagon: "六角形",
        triangle: "三角形",
        cross: "十字形",
        circle: "円形",
        custom: "カスタム画像",
      };

      // 画像処理関数
      class ImageProcessor {
        static async loadImage(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
              const img = new Image();
              img.onload = () => resolve(img);
              img.onerror = reject;
              img.src = e.target.result;
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
          });
        }

        static extractAlphaChannel(canvas, ctx, threshold = 128) {
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          const binaryMask = [];

          for (let y = 0; y < canvas.height; y++) {
            binaryMask[y] = [];
            for (let x = 0; x < canvas.width; x++) {
              const idx = (y * canvas.width + x) * 4;
              const alpha = data[idx + 3];
              binaryMask[y][x] = alpha > threshold ? 1 : 0;
            }
          }

          return binaryMask;
        }

        static findContour(binaryMask) {
          const height = binaryMask.length;
          const width = binaryMask[0].length;
          const contourPoints = [];

          // Moore近傍追跡アルゴリズム
          let startX = -1,
            startY = -1;

          // 開始点を見つける
          outer: for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              if (binaryMask[y][x] === 1) {
                startX = x;
                startY = y;
                break outer;
              }
            }
          }

          if (startX === -1) return [];

          // 8方向の近傍
          const neighbors = [
            [-1, -1],
            [0, -1],
            [1, -1],
            [1, 0],
            [1, 1],
            [0, 1],
            [-1, 1],
            [-1, 0],
          ];

          let x = startX,
            y = startY;
          let dir = 0; // 開始方向
          const visited = new Set();

          do {
            contourPoints.push([x, y]);
            visited.add(`${x},${y}`);

            // 次の輪郭点を探す
            let found = false;
            for (let i = 0; i < 8; i++) {
              const checkDir = (dir + i) % 8;
              const nx = x + neighbors[checkDir][0];
              const ny = y + neighbors[checkDir][1];

              if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                if (binaryMask[ny][nx] === 1 && !visited.has(`${nx},${ny}`)) {
                  x = nx;
                  y = ny;
                  dir = (checkDir + 6) % 8; // 次の開始方向
                  found = true;
                  break;
                }
              }
            }

            if (!found) break;
          } while (
            !(x === startX && y === startY) &&
            contourPoints.length < width * height
          );

          return contourPoints;
        }

        static simplifyContour(points, tolerance = 2) {
          // Douglas-Peucker アルゴリズムによる簡略化
          if (points.length <= 2) return points;

          const douglasPeucker = (points, start, end, tolerance) => {
            let maxDist = 0;
            let maxIndex = 0;

            for (let i = start + 1; i < end; i++) {
              const dist = this.perpendicularDistance(
                points[i],
                points[start],
                points[end]
              );
              if (dist > maxDist) {
                maxDist = dist;
                maxIndex = i;
              }
            }

            if (maxDist > tolerance) {
              const leftPoints = douglasPeucker(
                points,
                start,
                maxIndex,
                tolerance
              );
              const rightPoints = douglasPeucker(
                points,
                maxIndex,
                end,
                tolerance
              );
              return [...leftPoints.slice(0, -1), ...rightPoints];
            } else {
              return [points[start], points[end]];
            }
          };

          return douglasPeucker(points, 0, points.length - 1, tolerance);
        }

        static perpendicularDistance(point, lineStart, lineEnd) {
          const dx = lineEnd[0] - lineStart[0];
          const dy = lineEnd[1] - lineStart[1];

          if (dx === 0 && dy === 0) {
            return Math.sqrt(
              Math.pow(point[0] - lineStart[0], 2) +
                Math.pow(point[1] - lineStart[1], 2)
            );
          }

          const normalLength = Math.sqrt(dx * dx + dy * dy);
          return (
            Math.abs(
              (point[0] - lineStart[0]) * dy - (point[1] - lineStart[1]) * dx
            ) / normalLength
          );
        }

        static normalizeContour(contour, targetSize = 100) {
          if (contour.length === 0) return [];

          // バウンディングボックスを計算
          let minX = Infinity,
            minY = Infinity;
          let maxX = -Infinity,
            maxY = -Infinity;

          for (const [x, y] of contour) {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }

          const width = maxX - minX;
          const height = maxY - minY;
          const scale = targetSize / Math.max(width, height);
          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;

          // 正規化（中心を原点に、サイズを調整）
          return contour.map(([x, y]) => [
            ((x - centerX) * scale) / targetSize,
            ((y - centerY) * scale) / targetSize,
          ]);
        }
      }

      // 画像アップロード処理
      function setupImageUpload() {
        const uploadSection = document.getElementById("uploadSection");
        const imageUpload = document.getElementById("imageUpload");

        // ドラッグ&ドロップ
        uploadSection.addEventListener("dragover", (e) => {
          e.preventDefault();
          uploadSection.classList.add("dragover");
        });

        uploadSection.addEventListener("dragleave", () => {
          uploadSection.classList.remove("dragover");
        });

        uploadSection.addEventListener("drop", async (e) => {
          e.preventDefault();
          uploadSection.classList.remove("dragover");

          const file = e.dataTransfer.files[0];
          if (file && file.type === "image/png") {
            await processImage(file);
          }
        });

        // ファイル選択
        imageUpload.addEventListener("change", async (e) => {
          const file = e.target.files[0];
          if (file) {
            await processImage(file);
          }
        });

        // スライダーイベント
        const simplifySlider = document.getElementById("simplifySlider");
        const alphaSlider = document.getElementById("alphaSlider");

        simplifySlider.addEventListener("input", (e) => {
          document.getElementById("simplifyValue").textContent = e.target.value;
          if (customImageData) {
            reprocessImage();
          }
        });

        alphaSlider.addEventListener("input", (e) => {
          document.getElementById("alphaValue").textContent = e.target.value;
          if (customImageData) {
            reprocessImage();
          }
        });
      }

      async function processImage(file) {
        try {
          const img = await ImageProcessor.loadImage(file);

          // 元画像を表示
          const originalCanvas = document.getElementById("originalCanvas");
          const originalCtx = originalCanvas.getContext("2d");

          // キャンバスサイズを設定
          const maxSize = 150;
          const scale = Math.min(maxSize / img.width, maxSize / img.height, 1);
          originalCanvas.width = img.width * scale;
          originalCanvas.height = img.height * scale;

          originalCtx.drawImage(
            img,
            0,
            0,
            originalCanvas.width,
            originalCanvas.height
          );

          // 画像データを保存
          customImageData = {
            img: img,
            canvas: originalCanvas,
            ctx: originalCtx,
          };

          // 輪郭を抽出
          extractContourFromImage();

          // UIを更新
          document.getElementById("uploadSection").classList.add("has-image");
          document.getElementById("imagePreview").classList.add("active");
          document.getElementById("customShapeBtn").style.display =
            "inline-block";

          // 情報を表示
          document.getElementById("imageInfo").innerHTML = `
                    サイズ: ${img.width}×${img.height}px<br>
                    ファイル: ${file.name}
                `;

          // カスタム形状を選択
          selectShape("custom");
        } catch (error) {
          console.error("画像処理エラー:", error);
          alert("画像の読み込みに失敗しました");
        }
      }

      function extractContourFromImage() {
        if (!customImageData) return;

        const { canvas, ctx } = customImageData;
        const alphaThreshold = parseInt(
          document.getElementById("alphaSlider").value
        );
        const simplifyLevel = parseInt(
          document.getElementById("simplifySlider").value
        );

        // アルファチャンネルを抽出
        const binaryMask = ImageProcessor.extractAlphaChannel(
          canvas,
          ctx,
          alphaThreshold
        );

        // 輪郭を検出
        let contour = ImageProcessor.findContour(binaryMask);

        // 輪郭を簡略化
        contour = ImageProcessor.simplifyContour(contour, 11 - simplifyLevel);

        // 正規化
        customImageContour = ImageProcessor.normalizeContour(contour);

        // 輪郭を描画
        drawContourPreview(contour, canvas.width, canvas.height);

        // マップを更新
        if (currentShape === "custom") {
          updateDraggableShapeAndSize();
        }
      }

      function reprocessImage() {
        extractContourFromImage();
      }

      function drawContourPreview(contour, width, height) {
        const contourCanvas = document.getElementById("contourCanvas");
        const contourCtx = contourCanvas.getContext("2d");

        contourCanvas.width = width;
        contourCanvas.height = height;

        contourCtx.clearRect(0, 0, width, height);
        contourCtx.strokeStyle = "#4444ff";
        contourCtx.lineWidth = 2;
        contourCtx.fillStyle = "rgba(68, 68, 255, 0.2)";

        if (contour.length > 0) {
          contourCtx.beginPath();
          contourCtx.moveTo(contour[0][0], contour[0][1]);
          for (let i = 1; i < contour.length; i++) {
            contourCtx.lineTo(contour[i][0], contour[i][1]);
          }
          contourCtx.closePath();
          contourCtx.fill();
          contourCtx.stroke();

          // 頂点を表示
          contourCtx.fillStyle = "#ff4444";
          for (const [x, y] of contour) {
            contourCtx.beginPath();
            contourCtx.arc(x, y, 2, 0, Math.PI * 2);
            contourCtx.fill();
          }
        }
      }

      function removeCustomImage() {
        customImageData = null;
        customImageContour = null;

        document.getElementById("uploadSection").classList.remove("has-image");
        document.getElementById("imagePreview").classList.remove("active");
        document.getElementById("customShapeBtn").style.display = "none";
        document.getElementById("imageUpload").value = "";

        // デフォルト形状に戻す
        selectShape("star");
      }

      // 形状生成関数
      function createShape(type, center, sizeInMeters) {
        const [lng, lat] = center;
        const earthRadius = 6371000;

        const latOffset = (sizeInMeters / earthRadius) * (180 / Math.PI);
        const lngOffset =
          ((sizeInMeters / earthRadius) * (180 / Math.PI)) /
          Math.cos((lat * Math.PI) / 180);

        let points = [];

        if (type === "custom" && customImageContour) {
          // カスタム画像の輪郭を使用
          points = customImageContour.map(([x, y]) => [
            lng + lngOffset * x,
            lat + latOffset * y,
          ]);
        } else {
          // 既存の形状生成コード
          switch (type) {
            case "star":
              for (let i = 0; i < 10; i++) {
                const angle = (Math.PI * 2 * i) / 10 - Math.PI / 2;
                const radius = i % 2 === 0 ? 1 : 0.4;
                points.push([
                  lng + lngOffset * radius * Math.cos(angle),
                  lat + latOffset * radius * Math.sin(angle),
                ]);
              }
              break;

            case "hexagon":
              for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 * i) / 6;
                points.push([
                  lng + lngOffset * Math.cos(angle),
                  lat + latOffset * Math.sin(angle),
                ]);
              }
              break;

            case "triangle":
              for (let i = 0; i < 3; i++) {
                const angle = (Math.PI * 2 * i) / 3 - Math.PI / 2;
                points.push([
                  lng + lngOffset * Math.cos(angle),
                  lat + latOffset * Math.sin(angle),
                ]);
              }
              break;

            case "cross":
              const w = 0.3;
              points = [
                [lng - lngOffset * w, lat + latOffset],
                [lng + lngOffset * w, lat + latOffset],
                [lng + lngOffset * w, lat + latOffset * w],
                [lng + lngOffset, lat + latOffset * w],
                [lng + lngOffset, lat - latOffset * w],
                [lng + lngOffset * w, lat - latOffset * w],
                [lng + lngOffset * w, lat - latOffset],
                [lng - lngOffset * w, lat - latOffset],
                [lng - lngOffset * w, lat - latOffset * w],
                [lng - lngOffset, lat - latOffset * w],
                [lng - lngOffset, lat + latOffset * w],
                [lng - lngOffset * w, lat + latOffset * w],
              ];
              break;

            case "circle":
              for (let i = 0; i < 32; i++) {
                const angle = (Math.PI * 2 * i) / 32;
                points.push([
                  lng + lngOffset * Math.cos(angle),
                  lat + latOffset * Math.sin(angle),
                ]);
              }
              break;
          }
        }

        // ポリゴンを閉じる
        if (
          points.length > 0 &&
          (points[0][0] !== points[points.length - 1][0] ||
            points[0][1] !== points[points.length - 1][1])
        ) {
          points.push(points[0]);
        }

        return points;
      }

      // 衝突判定関数
      function polygonsIntersect(poly1, poly2) {
        function pointInPolygon(point, polygon) {
          let inside = false;
          const x = point[0],
            y = point[1];

          for (
            let i = 0, j = polygon.length - 2;
            i < polygon.length - 1;
            j = i++
          ) {
            const xi = polygon[i][0],
              yi = polygon[i][1];
            const xj = polygon[j][0],
              yj = polygon[j][1];

            const intersect =
              yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
            if (intersect) inside = !inside;
          }

          return inside;
        }

        function lineSegmentsIntersect(p1, p2, p3, p4) {
          const ccw = (A, B, C) => {
            return (
              (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])
            );
          };
          return (
            ccw(p1, p3, p4) !== ccw(p2, p3, p4) &&
            ccw(p1, p2, p3) !== ccw(p1, p2, p4)
          );
        }

        for (let i = 0; i < poly1.length - 1; i++) {
          if (pointInPolygon(poly1[i], poly2)) return true;
        }
        for (let i = 0; i < poly2.length - 1; i++) {
          if (pointInPolygon(poly2[i], poly1)) return true;
        }

        for (let i = 0; i < poly1.length - 1; i++) {
          for (let j = 0; j < poly2.length - 1; j++) {
            if (
              lineSegmentsIntersect(
                poly1[i],
                poly1[i + 1],
                poly2[j],
                poly2[j + 1]
              )
            ) {
              return true;
            }
          }
        }

        return false;
      }

      function getPolygonCenter(polygon) {
        let sumLng = 0,
          sumLat = 0;
        const count = polygon.length - 1;
        for (let i = 0; i < count; i++) {
          sumLng += polygon[i][0];
          sumLat += polygon[i][1];
        }
        return [sumLng / count, sumLat / count];
      }

      function calculateDistance(coord1, coord2) {
        const R = 6371000;
        const rad = Math.PI / 180;
        const lat1 = coord1[1] * rad;
        const lat2 = coord2[1] * rad;
        const deltaLat = (coord2[1] - coord1[1]) * rad;
        const deltaLng = (coord2[0] - coord1[0]) * rad;

        const a =
          Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
          Math.cos(lat1) *
            Math.cos(lat2) *
            Math.sin(deltaLng / 2) *
            Math.sin(deltaLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c;
      }

      // POIデータ
      const poiData = {
        type: "FeatureCollection",
        features: [
          {
            type: "Feature",
            properties: {
              name: "東京駅",
              shapeType: "hexagon",
              size: 30,
            },
            geometry: {
              type: "Polygon",
              coordinates: [createShape("hexagon", [139.7671, 35.6812], 30)],
            },
          },
          {
            type: "Feature",
            properties: {
              name: "皇居",
              shapeType: "star",
              size: 40,
            },
            geometry: {
              type: "Polygon",
              coordinates: [createShape("star", [139.7536, 35.6852], 40)],
            },
          },
          {
            type: "Feature",
            properties: {
              name: "日比谷公園",
              shapeType: "triangle",
              size: 35,
            },
            geometry: {
              type: "Polygon",
              coordinates: [createShape("triangle", [139.7563, 35.6742], 35)],
            },
          },
          {
            type: "Feature",
            properties: {
              name: "銀座",
              shapeType: "cross",
              size: 30,
            },
            geometry: {
              type: "Polygon",
              coordinates: [createShape("cross", [139.7638, 35.6719], 30)],
            },
          },
          {
            type: "Feature",
            properties: {
              name: "有楽町駅",
              shapeType: "circle",
              size: 25,
            },
            geometry: {
              type: "Polygon",
              coordinates: [createShape("circle", [139.7638, 35.6751], 25)],
            },
          },
        ],
      };

      // ドラッグ可能マーカー
      const draggableMarker = {
        type: "FeatureCollection",
        features: [
          {
            type: "Feature",
            properties: {
              name: "ドラッグ可能図形",
              shapeType: currentShape,
              size: currentSize,
            },
            geometry: {
              type: "Polygon",
              coordinates: [
                createShape(currentShape, draggableCenter, currentSize),
              ],
            },
          },
        ],
      };

      // 衝突判定
      function checkCollisions() {
        const collisions = [];
        const draggablePolygon =
          draggableMarker.features[0].geometry.coordinates[0];

        poiData.features.forEach((poi) => {
          const poiPolygon = poi.geometry.coordinates[0];

          if (polygonsIntersect(draggablePolygon, poiPolygon)) {
            const poiCenter = getPolygonCenter(poiPolygon);
            const distance = calculateDistance(draggableCenter, poiCenter);

            collisions.push({
              name: poi.properties.name,
              shapeType: poi.properties.shapeType,
              size: poi.properties.size,
              distance: Math.round(distance),
            });
          }
        });

        return collisions;
      }

      // UI更新
      function updateUI() {
        const collisions = checkCollisions();
        const statusEl = document.getElementById("status");
        const collisionsEl = document.getElementById("collisions");
        const coordsEl = document.getElementById("coordinates");

        coordsEl.innerHTML = `中心座標: [${draggableCenter[0].toFixed(
          4
        )}, ${draggableCenter[1].toFixed(4)}]`;

        // 統計情報
        document.getElementById("currentShapeDisplay").textContent =
          shapeNames[currentShape];
        const vertices =
          draggableMarker.features[0].geometry.coordinates[0].length - 1;
        document.getElementById("verticesDisplay").textContent = vertices;

        if (collisions.length > 0) {
          statusEl.className = "status collision";
          statusEl.textContent = `⚠️ ${collisions.length}件の衝突を検出`;

          collisionsEl.innerHTML = collisions
            .map(
              (c) =>
                `<div class="collision-item">
                        <strong>${c.name}</strong> (${c.shapeType}, ${c.size}m)
                        <br>中心間距離: ${c.distance}m
                    </div>`
            )
            .join("");

          map.setPaintProperty(
            "draggable-fill",
            "fill-color",
            "rgba(255, 100, 100, 0.6)"
          );
          map.setPaintProperty("draggable-outline", "line-color", "#ff4444");
        } else {
          statusEl.className = "status safe";
          statusEl.textContent = "✓ 衝突なし";
          collisionsEl.innerHTML = "";

          map.setPaintProperty(
            "draggable-fill",
            "fill-color",
            "rgba(100, 100, 255, 0.4)"
          );
          map.setPaintProperty("draggable-outline", "line-color", "#4444ff");
        }
      }

      // 形状とサイズの更新
      function updateDraggableShapeAndSize() {
        draggableMarker.features[0].geometry.coordinates = [
          createShape(currentShape, draggableCenter, currentSize),
        ];
        draggableMarker.features[0].properties.shapeType = currentShape;
        draggableMarker.features[0].properties.size = currentSize;

        if (map && map.getSource("draggable")) {
          map.getSource("draggable").setData(draggableMarker);
          updateUI();
        }
      }

      // 形状選択
      function selectShape(shape) {
        currentShape = shape;
        document.querySelectorAll(".shape-btn").forEach((b) => {
          b.classList.remove("active");
          if (b.dataset.shape === shape) {
            b.classList.add("active");
          }
        });
        updateDraggableShapeAndSize();
      }

      // イベントリスナー
      document.querySelectorAll(".shape-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          selectShape(e.target.dataset.shape);
        });
      });

      const sizeSlider = document.getElementById("sizeSlider");
      sizeSlider.addEventListener("input", (e) => {
        currentSize = parseInt(e.target.value);
        document.getElementById("sizeValue").textContent = `${currentSize}m`;
        updateDraggableShapeAndSize();
      });

      // マップ初期化
      function initMap() {
        map = new maplibregl.Map({
          container: "map",
          style: {
            version: 8,
            glyphs:
              "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
            sources: {
              osm: {
                type: "raster",
                tiles: ["https://a.tile.openstreetmap.org/{z}/{x}/{y}.png"],
                tileSize: 256,
                attribution: "© OpenStreetMap contributors",
              },
            },
            layers: [
              {
                id: "osm",
                type: "raster",
                source: "osm",
              },
            ],
          },
          center: [139.767, 35.6814],
          zoom: 16,
        });

        map.on("load", () => {
          // POIの追加
          map.addSource("pois", {
            type: "geojson",
            data: poiData,
          });

          map.addLayer({
            id: "poi-fill",
            type: "fill",
            source: "pois",
            paint: {
              "fill-color": "rgba(255, 100, 100, 0.4)",
              "fill-outline-color": "#ff4444",
            },
          });

          map.addLayer({
            id: "poi-outline",
            type: "line",
            source: "pois",
            paint: {
              "line-color": "#ff4444",
              "line-width": 2,
            },
          });

          map.addLayer({
            id: "poi-labels",
            type: "symbol",
            source: "pois",
            layout: {
              "text-field": [
                "concat",
                ["get", "name"],
                "\n",
                ["get", "size"],
                "m",
              ],
              "text-font": ["Open Sans Regular", "Arial Unicode MS Regular"],
              "text-size": 11,
              "text-anchor": "center",
              "text-line-height": 1.2,
            },
            paint: {
              "text-color": "#333",
              "text-halo-color": "#fff",
              "text-halo-width": 2,
            },
          });

          // ドラッグ可能マーカー
          map.addSource("draggable", {
            type: "geojson",
            data: draggableMarker,
          });

          map.addLayer({
            id: "draggable-fill",
            type: "fill",
            source: "draggable",
            paint: {
              "fill-color": "rgba(100, 100, 255, 0.4)",
              "fill-outline-color": "#4444ff",
            },
          });

          map.addLayer({
            id: "draggable-outline",
            type: "line",
            source: "draggable",
            paint: {
              "line-color": "#4444ff",
              "line-width": 3,
            },
          });

          map.addLayer({
            id: "draggable-label",
            type: "symbol",
            source: "draggable",
            layout: {
              "text-field": ["concat", "ドラッグ\n", ["get", "size"], "m"],
              "text-font": ["Open Sans Regular", "Arial Unicode MS Regular"],
              "text-size": 11,
              "text-anchor": "center",
              "text-line-height": 1.2,
            },
            paint: {
              "text-color": "#fff",
              "text-halo-color": "#4444ff",
              "text-halo-width": 2,
            },
          });

          // ドラッグ機能
          map.on("mouseenter", "draggable-fill", () => {
            map.getCanvas().style.cursor = "move";
          });

          map.on("mouseleave", "draggable-fill", () => {
            if (!isDragging) {
              map.getCanvas().style.cursor = "";
            }
          });

          map.on("mousedown", "draggable-fill", (e) => {
            e.preventDefault();
            isDragging = true;
            map.getCanvas().style.cursor = "grabbing";
            map.dragPan.disable();
          });

          map.on("mousemove", (e) => {
            if (!isDragging) return;

            draggableCenter = [e.lngLat.lng, e.lngLat.lat];
            draggableMarker.features[0].geometry.coordinates = [
              createShape(currentShape, draggableCenter, currentSize),
            ];
            map.getSource("draggable").setData(draggableMarker);
            updateUI();
          });

          map.on("mouseup", () => {
            if (isDragging) {
              isDragging = false;
              map.getCanvas().style.cursor = "";
              map.dragPan.enable();
            }
          });

          // タッチ対応
          let touchId = null;

          map.on("touchstart", "draggable-fill", (e) => {
            if (e.points.length !== 1) return;
            e.preventDefault();

            touchId = e.originalEvent.touches[0].identifier;
            isDragging = true;
            map.dragPan.disable();
          });

          map.on("touchmove", (e) => {
            if (!isDragging || touchId === null) return;

            const touch = e.originalEvent.touches[0];
            if (touch.identifier !== touchId) return;

            draggableCenter = [e.lngLat.lng, e.lngLat.lat];
            draggableMarker.features[0].geometry.coordinates = [
              createShape(currentShape, draggableCenter, currentSize),
            ];
            map.getSource("draggable").setData(draggableMarker);
            updateUI();
          });

          map.on("touchend", () => {
            if (isDragging) {
              isDragging = false;
              touchId = null;
              map.dragPan.enable();
            }
          });

          updateUI();
        });

        map.addControl(new maplibregl.NavigationControl());
      }

      // 初期化
      window.addEventListener("DOMContentLoaded", () => {
        initMap();
        setupImageUpload();
      });
    </script>
  </body>
</html>
